Tema 1 - SDA
Prelucrarea si analizarea datelor secventiale

1. Formatul datelor
Pentru memorarea si reprezentarea datelor am folosit liste dublu inlantuite,
avand variabila timestamp de tip int si value de tip double. De asemenea, urmatoarele
functii sunt folosite pentru lucrul cu listele dublu inlantuite:
- init_node pentru initializarea unui nod;
- init_list pentru initializarea unei liste;
- free_node pentru eliberarea memoriei a unui nod;
- destroy_list pentru eliberarea memoriei a unei liste;
- insert_node pentru a introduce un nod in lista la o pozitie data;
- remove_node pentru a elimina un nod din lista la o pozitie data;

2. Sarcini de lucru

2.1 Eliminare de exceptii folosind metode statistice
Pentru acest task am creat doua functii pentru aflarea formulelor.
Functia medie_fereastra primeste ca argument nodul din mijlocul unei ferestre de 5 noduri si 
calculeaza media conform formulei. Functia deviatia_standard primeste ca argument tot nodul din
mijloc si calculeaza deviatia conform formulei.
Deoarece primele k/2 si ultimele k/2 valori din lista vor fi ignorate, incep parcurgerea 
listei de la al treilea nod, cat timp nodul este diferit de penultimul. Am luat o lista noua in care am 
retinut nodurile care nu se afla in intervalul [medie-deviatie; medie+deviatie]. Apoi, incep parcurgerea 
listei in care se afla nodurile ce trebuie eliminate si parcurg lista initiala de la nodul al treilea. 
Cresc pozitia de fiecare data cand parcurg un nod din lista initiala, iar daca gasesc nodul trec la cel 
anterior ca sa il elimin pe curentul, trec la urmatorul nod din aux daca este cazul si scad pozitia. 
La sfarsit eliberez memoria folosita de lista de eliminare si dau return la lista.

2.2 Eliminare de zgomot folosind filtre
2.2.1 Filtrare mediana
Pentru acest task am creat functia construire_fereastra care construieste o fereastra de 5 noduri.
De asemenea, folosesc functia insert_sorted pentru a sorta fereastra. Incep parcurgerea listei mele
de la nodul al treilea, construiesc o fereastra pentru fiecare pe care apoi o sortez si retin nodul 
din mijlocul ferestrei initiale pentru a-i pastra timestampul. Apoi intr-o lista noua introduc toate
nodurile aflate in mijloc si eliberez memoria pentru listele sorted_window, window si list, doearece voi returna
newlist.
2.2.2 Filtrare folosind media aritmetica
Parcurg lista incepand de la al treilea nod si ma folosesc de functia de medie folosita la 2.1
si introduc intr-o lista noua nodurile cu valoarea mediei si timestampul nodului curent. La sfarsit eliberez
memoria listei initiale deoarece returnez newlist.

2.3 Uniformizarea frecventei in timp a datelor
Parcurg lista incepand cu al doilea element, retin in x diferenta dintre timestampul nodului curent
si a celui anterior si daca valoarea sa nu se afla intre 100 si 1000 milisecunde(0.1-1 secunde) timestampul si
valoarea devin media aritmetica a celor doua noduri.

2.4 Completarea datelor
Incep parcurgerea listei de la al treilea nod, cat timp nodul este diferit de penultimul, pentru a putea lua
ferestrele de 3 vecini. Retin in x diferenta dintre timestampul nodului urmator si cea a celui curent si
daca este mai mare decat 1000, incep inserarea de noi elemente. Retin in niste variabile timestampurile celor 2 noduri
si valorile celor 6 noduri din cele 2 ferestre de 3. Apoi, cat timp noul timestamp al elementului ce urmeaza a fi
introdus este mai mic decat cel al nodului din dreapta, calculez suma din formula w(i,k), calculez c-ul, iar apoi
calculez cele trei w(i,k) pe care le voi inmulti cu nodurile din ferestre conform formulei. In newvalue retin
valoarea data de formula, cresc pozitia pe care ma aflu deoarece voi introduce un nod nou pe care ma voi muta si pe 
newtimestamp il adun cu 200, deoarece astfel voi putea avea cel putin 5 valori intr-un interval de 1 secunda
(1000 milisecunde). La sfarsit voi creste iar pozitia si voi trece la nodul urmator.

2.5 Statistici
Pentru a afla intervalul de lungime, verific cu strstr daca argumentul primit contine '--st', iar apoi iau un sir de
caractere in care retin argumentul cu strcpy, iar apoi folosesc iar strcpy pentru elimina '--st' ca sa raman astfel
doar cu lungimea. Apoi, declar o variabila int nr si folosesc atoi pentru convertirea stringului in int.
In functia statistici sortez lista primita, iar apoi retin in intervalc1 valoarea rotunjita mai mica a nodului folosind floor,
iar in intervalc2 valoarea primului interval adunat cu lungimea data ca parametru. Iau un ok care initial e 1.
Daca nodul se afla in interval, cresc numarul de numere. Daca nu se afla, ok devine 0 si daca ok este 0,
afisez intervalul si numarul de numere din el. Apoi, cat timp intervalc2 este mai mic sau egal decat valoarea nodului,
intervalc1 devine intervalc2 si intervalc2 este adunat cu l. Astfel, trec peste intervalele care nu au niciun numar.
Ajungand la intervalul in care se afla nodul curent, cresc numarul pe care il reinitializasem cu 0 inainte sa trec la
nodul urmator si ok devine iar 1. La sfarsit voi printa ultimul interval deoarece acesta era omis si eliberez memoria
pentru lista sortata.

3 Mod de rulare

Pentru a putea rula, iau un for de la 1 la argc, si verific ce string am primit ca argument, apeland apoi
functia facuta pentru taskul respectiv. Pentru e1, e2, e3, u, c voi printa lista finala. La final eliberez memoria listei.